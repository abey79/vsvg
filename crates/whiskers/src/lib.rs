pub mod context;
pub mod prelude;
pub mod runner;
pub mod sketch;
pub mod widgets;

pub type Result = anyhow::Result<()>;

pub use sketch::Sketch;

pub use runner::Runner;

/// This is the trait that your sketch app must implement.
pub trait App {
    fn update(&mut self, sketch: &mut Sketch, ctx: &mut context::Context) -> anyhow::Result<()>;

    //TODO:
    // - extra ui?
    // - extra CLI?
}

pub trait SketchUI {
    /// Draw the UI for the sketch, return whether the sketch should be updated.
    ///
    /// This function is generated by the [`Sketch`] derive macro.
    fn ui(&mut self, ui: &mut egui::Ui) -> bool;
}

pub trait SketchApp: App + SketchUI {
    /// The name of the sketch, used the window title, the default output file name, and persistent
    /// settings.
    fn name(&self) -> String;
}

/// Declare the main entry point for wasm builds.
///
/// Note: this macro requires `use whiskers::prelude::*;` to be present in the module.
#[macro_export]
macro_rules! wasm_sketch {
    ($t: expr) => {
        #[cfg(target_arch = "wasm32")]
        #[wasm_bindgen::prelude::wasm_bindgen]
        pub async fn start(
            handle: &vsvg_viewer::web_handle::WebHandle,
            canvas_id: &str,
        ) -> std::result::Result<(), wasm_bindgen::JsValue> {
            handle.start(canvas_id, $t).await
        }

        #[cfg(not(target_arch = "wasm32"))]
        pub fn main_func() -> Result {
            $t.run()
        }

        #[cfg(target_arch = "wasm32")]
        pub fn main_func() -> Result {
            Ok(())
        }
    };
}

#[macro_export]
macro_rules! wasm_main {
    ($lib: ident) => {
        fn main() -> whiskers::prelude::anyhow::Result<()> {
            $lib::main_func()
        }
    };
}
