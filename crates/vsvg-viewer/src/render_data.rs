use crate::engine::{
    CONTROL_POINTS_COLOR, CONTROL_POINTS_SIZE, DisplayOptions, EngineRenderObjects,
    PEN_UP_TRAJECTORY_COLOR, POINTS_COLOR, POINTS_SIZE,
};
use crate::painters::{BasicPainterData, LinePainterData, PointPainterData};
use rayon::prelude::*;
use std::collections::HashMap;
use std::sync::Arc;
use vsvg::{Document, FlattenedLayer, LayerID, LayerTrait, PathTrait, Point};

/// Data needed for drawing the Bézier handles.
pub(crate) struct BezierHandlesPainterData {
    pub point_painter_data: PointPainterData,
    pub line_painter_data: BasicPainterData,
}

/// Cache of all data needed to render a single layer of a [`Document`].
///
/// All data is computed on demand and cached.
///
/// Implementation note: this struct reflects the two stages of the WGPU call-back: mutable
/// preparation and immutable rendering. The preparation stage is done by [`Self::prepare()`]. The
/// rendering stage is done using the various `*_painter_data()` accessors, which are precomputed by
/// [`Self::prepare()`].
pub(crate) struct LayerRenderData {
    document: Arc<Document>,
    layer_id: LayerID,

    /// number of vertices after flattening
    vertex_count: u64,

    // BASE DATA
    display_options: DisplayOptions,
    flattened_layer: Option<FlattenedLayer>,
    line_painter_data: Option<LinePainterData>,

    // BEZIER HANDLES
    /// List of handles for the Bézier curves.
    bezier_handles: Option<FlattenedLayer>,
    bezier_handles_painter_data: Option<BezierHandlesPainterData>,

    // DISPLAY VERTICES
    /// Display vertices
    ///
    /// These are the vertices originating from the raw data, excluding the vertices generated by
    /// the flattening process.
    display_vertices: Option<Vec<Point>>,
    display_vertices_painter_data: Option<PointPainterData>,

    // PEN-UP
    pen_up_painter_data: Option<BasicPainterData>,
}

impl LayerRenderData {
    pub fn new(document: Arc<Document>, layer_id: LayerID) -> Self {
        vsvg::trace_function!();

        Self {
            document,
            layer_id,
            vertex_count: 0,
            display_options: DisplayOptions::default(),
            flattened_layer: None,
            line_painter_data: None,
            bezier_handles: None,
            bezier_handles_painter_data: None,
            display_vertices: None,
            display_vertices_painter_data: None,
            pen_up_painter_data: None,
        }
    }

    pub fn vertex_count(&self) -> u64 {
        self.vertex_count
    }

    pub fn line_painter_data(&self) -> Option<&LinePainterData> {
        self.line_painter_data.as_ref()
    }

    pub fn bezier_handles_painter_data(&self) -> Option<&BezierHandlesPainterData> {
        self.bezier_handles_painter_data.as_ref()
    }

    pub fn display_vertices_painter_data(&self) -> Option<&PointPainterData> {
        self.display_vertices_painter_data.as_ref()
    }

    pub fn pen_up_painter_data(&self) -> Option<&BasicPainterData> {
        self.pen_up_painter_data.as_ref()
    }

    /// Invalidate our cache based on the provided display options.
    #[allow(clippy::float_cmp)]
    fn invalidate_display_options(&mut self, display_options: &DisplayOptions) {
        if display_options.tolerance != self.display_options.tolerance {
            self.flattened_layer = None;
            self.line_painter_data = None;
        }

        if display_options.line_display_options != self.display_options.line_display_options {
            self.line_painter_data = None;
        }

        self.display_options = *display_options;
    }

    /// Ensure all the data needed for the provided [`DisplayOptions`] is generated.
    pub fn prepare(
        &mut self,
        render_objects: &EngineRenderObjects,
        display_options: DisplayOptions,
    ) {
        vsvg::trace_function!();

        // check the provided options and invalidate our cache if needed
        self.invalidate_display_options(&display_options);

        self.prepare_line_painter_data(render_objects);

        if display_options.show_display_vertices {
            self.prepare_display_vertices_painter_data(render_objects);
        }

        if display_options.show_pen_up {
            self.prepare_pen_up_painter_data(render_objects);
        }

        if display_options.show_bezier_handles {
            self.prepare_bezier_handles_painter_data(render_objects);
        }
    }

    fn prepare_line_painter_data(&mut self, render_objects: &EngineRenderObjects) {
        vsvg::trace_function!();

        let flattened_layer = self.flattened_layer.get_or_insert_with(|| {
            self.document.layers[&self.layer_id].flatten(self.display_options.tolerance)
        });

        self.vertex_count = flattened_layer.vertex_count();

        if self.line_painter_data.is_none() {
            self.line_painter_data = Some(LinePainterData::new(
                render_objects,
                &flattened_layer.paths,
                &self.display_options.line_display_options,
            ));
        }
    }

    fn prepare_bezier_handles_painter_data(&mut self, render_objects: &EngineRenderObjects) {
        vsvg::trace_function!();

        let bezier_handles = self
            .bezier_handles
            .get_or_insert_with(|| self.document.layers[&self.layer_id].bezier_handles());

        if self.bezier_handles_painter_data.is_none() {
            let handle_points: Vec<_> = bezier_handles
                .paths
                .par_iter()
                .flat_map(|p| p.data().points())
                .map(Into::into)
                .collect();

            self.bezier_handles_painter_data = Some(BezierHandlesPainterData {
                point_painter_data: PointPainterData::new(
                    render_objects,
                    handle_points.clone(),
                    CONTROL_POINTS_COLOR,
                    CONTROL_POINTS_SIZE,
                ),
                line_painter_data: BasicPainterData::new(
                    render_objects,
                    handle_points,
                    CONTROL_POINTS_COLOR,
                ),
            });
        }
    }

    fn prepare_display_vertices_painter_data(&mut self, render_objects: &EngineRenderObjects) {
        vsvg::trace_function!();

        let display_vertices = self
            .display_vertices
            .get_or_insert_with(|| self.document.layers[&self.layer_id].display_vertices());

        if self.display_vertices_painter_data.is_none() {
            self.display_vertices_painter_data = Some(PointPainterData::new(
                render_objects,
                display_vertices.iter().map(Into::into),
                POINTS_COLOR,
                POINTS_SIZE,
            ));
        }
    }

    /// Ensure the data needed for pen up trajectories is generated.
    ///
    /// This function must be called after [`Self::prepare_line_painter_data`] has been called.
    fn prepare_pen_up_painter_data(&mut self, render_objects: &EngineRenderObjects) {
        vsvg::trace_function!();

        if let Some(flattened_layer) = &self.flattened_layer
            && self.pen_up_painter_data.is_none()
        {
            let pen_up_trajectories = flattened_layer
                .pen_up_trajectories()
                .par_iter()
                .flat_map(|(start, end)| [start.into(), end.into()])
                .collect::<Vec<[f32; 2]>>();

            self.pen_up_painter_data = Some(BasicPainterData::new(
                render_objects,
                pen_up_trajectories,
                PEN_UP_TRAJECTORY_COLOR,
            ));
        }
    }
}

pub(crate) struct RenderData {
    document: Arc<Document>,
    layers: HashMap<LayerID, LayerRenderData>,
}

impl RenderData {
    pub fn new(document: Arc<Document>) -> Self {
        vsvg::trace_function!();

        let layers = document
            .layers
            .keys()
            .map(|layer_id| (*layer_id, LayerRenderData::new(document.clone(), *layer_id)))
            .collect();

        Self { document, layers }
    }

    pub fn document(&self) -> &Arc<Document> {
        &self.document
    }

    pub fn prepare(
        &mut self,
        render_objects: &EngineRenderObjects,
        display_options: DisplayOptions,
    ) {
        vsvg::trace_function!();

        for layer_data in self.layers.values_mut() {
            layer_data.prepare(render_objects, display_options);
        }
    }

    pub fn layers(&self) -> &HashMap<LayerID, LayerRenderData> {
        &self.layers
    }
}
